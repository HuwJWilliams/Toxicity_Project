"""
Script that holds the functions used to visualise all of the data in this project
"""
# %% --- Imports
import pandas as pd
from pathlib import Path
import sys
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import seaborn as sns
import json
from glob import glob
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import LocalOutlierFactor
from scipy.spatial import ConvexHull
import random as rand
from typing import Union

sys.path.insert(0, "../")
from group_descriptors import getGroups

# %% --- Pathing
FILE_DIR = Path(__file__).resolve()
PROJ_DIR = FILE_DIR.parents[2]
RESULTS_DIR = Path(PROJ_DIR / "results" / "LD50_predictions_rf")

# %% --- Visualisation Class

class Visualise():
    """
    Class containing all visualisation and plotting functions used in this project.

    This class provides a unified interface for generating, formatting, and saving 
    various types of plots (e.g., PCA, bar charts, heatmaps, radar plots) used to 
    analyse descriptor and model performance.
    """
    def __init__(
            self,
            save_all: bool=False,
            save_path: Path=None
    ):
        """
        Initializes the plotting utility class.

        Parameters
        ----------
        save_all : bool
                            If True, automatically saves all plots generated by the class 
                            without needing to specify `save_plot=True` for each function.
                            Default = False.
        save_path : Path
                            Default directory to save plots to. If None, plots are saved 
                            to the current working directory.
                            Default = None.
        """

        self.save_all = save_all
        self.save_path = save_path

        # Set colour consistent colour mapping for each descriptor group
        palette = plt.get_cmap("tab10")

        self.colour_map = {
            "rdkit": palette(0),
            "mordred": palette(1),
            "chemberta": palette(2),
            "molformer": palette(3)
        }

        # Set default colour to black incase labels dont match colour map
        self.default_colour = (0.0, 0.0, 0.0, 1.0)

    def _getColour(self, name:str) -> tuple:
        """
        Retrieves the RGBA colour associated with a given label.

        Parameters
        ----------
        name : str
                            Label to look up in the internal colour map.

        Returns
        -------
        tuple
                            An RGBA tuple representing the colour (R, G, B, A).
        """


        for key, colour in self.colour_map.items():
            if key.lower() in name.lower():
                return colour
        return self.default_colour

    def _savePlot(
            self,
            save_plot: bool, 
            save_path: Union[str, Path], 
            save_fname: str, 
            dpi: int,
            description: str="Saved plot",
            fig: plt.Figure | None=None
            ):
        """
        Saves a matplotlib figure.

        This helper function standardises plot saving across the project. It can save 
        either a provided matplotlib figure or the current active plot (`plt.gcf()`), 
        automatically handling directory creation and defaulting to a `.png` extension 
        if none is specified.

        Parameters
        ----------
        save_plot : bool
                            Whether to save the plot.
        save_path : str, Path
                            Directory to save the plot to.
        save_fname : str
                            Filename to save the plot under. If no extension is provided,
                            ".png" will be appended automatically.
        dpi : int
                            Dots per inch (image resolution) for the saved figure.
        description : str (optional)
                            Message printed to confirm where the plot was saved.
                            Default = "Saved plot".
        fig : plt.Figure (optional)
                            Figure object to save. If None, saves the current active 
                            figure (`plt.gcf()`).
                            Default = None.

        Returns
        -------
        None
                            Saves the plot to disk and prints the save location.
        """


        if save_plot or self.save_all:
            save_path = Path(save_path)
            save_path.mkdir(parents=True, exist_ok=True)
            full_save_path = save_path / save_fname

            # ensure filename has a valid extension
            save_fname = str(save_fname)
            if not any(save_fname.lower().endswith(ext) for ext in [".png", ".jpg", ".jpeg", ".svg", ".pdf"]):
                save_fname += ".png"

            # use provided figure, or fall back to the current one
            fig_to_save = fig or plt.gcf()
            fig_to_save.savefig(full_save_path, dpi=dpi, bbox_inches="tight")

            print(f"Saved {description} to\n{full_save_path}")

    def _loadData(
            self,
            df: str | pd.DataFrame | Path,
            index_col: int | str=0,
            exclude: list[str]=[],
            wildcard: str="*"
    ) -> pd.DataFrame:
        """
        Flexibly loads data into a pandas DataFrame from various input types.

        This function accepts either a file path, a wildcard pattern (to merge 
        multiple CSV files), or an existing DataFrame. It standardises the input 
        into a clean, indexed DataFrame and optionally removes specified columns.

        Parameters
        ----------
        df : str, Path, pd.DataFrame
                            Path to a CSV file, a wildcard pattern (e.g., "*.csv"), 
                            or an existing DataFrame.
        index_col : int, str (optional)
                            Column to use as the index when reading CSV files.
                            Default = 0.
        exclude : list[str] (optional)
                            List of column names to drop after loading.
                            Default = [].
        wildcard : str (optional)
                            Character used to denote a wildcard pattern when loading 
                            multiple files.
                            Default = "*".

        Returns
        -------
        pd.DataFrame
                            A single DataFrame containing all loaded and cleaned data.

        Raises
        ------
        TypeError
                            If the input is not a path (str/Path) or a pandas DataFrame.
        """
        if isinstance(df, (str, Path)) and wildcard in str(df):
            loaded_df = pd.concat([pd.read_csv(f, index_col="ID") for f in glob(df)], axis=0)

        elif isinstance(df, (str, Path)):
            loaded_df = pd.read_csv(df, index_col=index_col)

        elif isinstance(df, pd.DataFrame):
            loaded_df = df.copy()

        else:
            raise TypeError("Input must be a path (str/Path) or a pandas DataFrame.")

        if exclude:
            loaded_df = loaded_df.drop(columns=[c for c in exclude if c in loaded_df.columns])

        return loaded_df
    
    def plotFeatureImportance(
            self,
            data: pd.DataFrame,
            x_col: str="Importance",
            y_col: str="Feature",
            ascending=False,
            top_n: int=None,
            title: str=None,
            title_fontsize: int=16,
            label_fontsize: int=14,
            tick_fontsize: int=12,
            figsize: tuple=(10, 8),
            save_plot: bool=False,
            save_path: Union[Path, str]=None,
            save_fname: str="feature_importance",
            dpi: int=400,
    ):
        """
        Generates a bar plot visualising feature importance scores for a given model.

        This function sorts and plots feature importance values, allowing visual 
        interpretation of which features contribute most (or least) to model 
        performance. It can optionally display only the top N most important features 
        and save the resulting plot as an image.

        Parameters
        ----------
        data : pd.DataFrame
                            DataFrame containing the feature names and their 
                            corresponding importance values.
        x_col : str (optional)
                            Name of the column containing numerical feature 
                            importance values.
                            Default = "Importance".
        y_col : str (optional)
                            Name of the column containing feature names.
                            Default = "Feature".
        ascending : bool (optional)
                            Whether to sort the features in ascending order.
                            Default = False.
        top_n : int (optional)
                            Number of top features to display in the plot.
                            Default = None.
        title : str (optional)
                            Title of the feature importance plot.
                            Default = None.
        title_fontsize : int (optional)
                            Font size for the plot title.
                            Default = 16.
        label_fontsize : int (optional)
                            Font size for axis labels.
                            Default = 14.
        tick_fontsize : int (optional)
                            Font size for tick labels.
                            Default = 12.
        figsize : tuple (optional)
                            Figure size as (width, height) in inches.
                            Default = (10, 8).
        save_plot : bool (optional)
                            Whether to save the generated plot as an image.
                            Default = False.
        save_path : str, Path (optional)
                            Directory to save the plot to if `save_plot=True`.
                            Default = None.
        save_fname : str (optional)
                            Filename to save the plot under (without extension).
                            Default = "feature_importance".
        dpi : int (optional)
                            Dots per inch (image resolution) for the saved plot.
                            Default = 400.

        Returns
        -------
        None
                            Displays the feature importance plot and optionally saves 
                            it to the specified directory.
        """


        # Sorting values by the x-column
        data = data.sort_values(by=x_col, ascending=ascending)

        # If specified, look at top_n number of features
        if top_n:
            data = data.head(top_n)

        # Setting the colour map
        palette = sns.color_palette("tab10", n_colors=len(data))
        colour_map = dict(zip(data[y_col], palette))

        # Plotting the figure
        plt.figure(figsize=figsize)
        sns.barplot(
            data=data,
            x=x_col,
            y=y_col,
            palette=colour_map,
            dodge=False,
            hue=y_col,
            legend=False
        )

        plt.title(title, fontsize=title_fontsize)
        plt.ylabel(y_col, fontsize=label_fontsize)
        plt.xlabel(x_col.capitalize(), fontsize=label_fontsize)

        plt.xticks(fontsize=tick_fontsize, rotation=45)
        plt.yticks(fontsize=tick_fontsize)
        plt.tight_layout()

        self._savePlot(
            save_plot=save_plot,
            save_path=save_path,
            save_fname=save_fname,
            dpi=dpi,
            description="feature importance plot"
        )

        plt.show()

    def plotMultiTaskPerformance(
            self,
            data: pd.DataFrame,
            x_col: str,
            y_col: str,
            ascending: bool=False,
            top_n: int=None,
            subset: str=None,
            figsize: tuple=(10, 8),
            title: str="Multi-Task Performance",
            title_fontsize: int=16,
            label_fontsize: int=14,
            tick_fontsize: int=12,
            save_plot: bool=False,
            save_path: Path=None,
            save_fname: str="multi-task_performance",
            dpi: int=400
    ):
        """
        Generates a horizontal bar chart visualising multi-task model performance 
        across different feature representations.

        This plot shows how models trained on one feature set perform when 
        predicting features from another, allowing comparison of cross-representation 
        transfer performance. The data can optionally be filtered by descriptor name 
        or limited to the top-performing features.

        Parameters
        ----------
        data : pd.DataFrame
                            DataFrame containing cross-feature performance values, 
                            where rows correspond to predicted features and columns 
                            include performance metrics.
        x_col : str
                            Name of the column containing the numerical performance 
                            metric to plot (e.g., "Pearson_r" or "R2").
        y_col : str
                            Name of the column or label representing the predicted 
                            feature set (used for the y-axis label).
        ascending : bool (optional)
                            Whether to sort the data in ascending order of the 
                            performance metric.
                            Default = False.
        top_n : int (optional)
                            Number of top (or bottom, if ascending=True) features 
                            to display in the plot.
                            Default = None.
        subset : str (optional)
                            Filters the data to include only features containing 
                            this string (case-insensitive).
                            Default = None.
        figsize : tuple (optional)
                            Size of the figure as (width, height) in inches.
                            Default = (10, 8).
        title : str (optional)
                            Title of the bar chart.
                            Default = "Multi-Task Performance".
        title_fontsize : int (optional)
                            Font size for the plot title.
                            Default = 16.
        label_fontsize : int (optional)
                            Font size for axis labels.
                            Default = 14.
        tick_fontsize : int (optional)
                            Font size for tick labels.
                            Default = 12.
        save_plot : bool (optional)
                            Whether to save the generated plot as an image.
                            Default = False.
        save_path : str, Path (optional)
                            Directory to save the plot to if `save_plot=True`.
                            Default = None.
        save_fname : str (optional)
                            Filename to save the plot under (without extension).
                            Default = "multi-task_performance".
        dpi : int (optional)
                            Dots per inch (image resolution) for the saved plot.
                            Default = 400.

        Returns
        -------
        None
                            Displays the bar chart and optionally saves it to the 
                            specified directory.
        """

        # Look for subset of desciptors containing the string "subset"
        if subset:
            data = data[data.index.astype(str).str.contains(subset, case=False, na=False)]

        # Ensure numerical values, drop N/A and sort values
        data = data.copy()
        data[x_col] = pd.to_numeric(data[x_col], errors="coerce")
        data = data.dropna(subset=[x_col])
        data = data.sort_values(by=x_col, ascending=ascending)

        # If specified, look at top_n number of features
        if top_n:
            data = data.head(top_n)


        # Plotting the figure
        plt.figure(figsize=figsize)
        plt.barh(data.index, data[x_col].values)
        plt.title(title, fontsize=title_fontsize)

        plt.xlabel(x_col.capitalize(), fontsize=label_fontsize)
        plt.ylabel(y_col, fontsize=label_fontsize)

        plt.yticks(fontsize=tick_fontsize)
        plt.xticks(fontsize=tick_fontsize)

        plt.tight_layout()

        self._savePlot(
            save_plot=save_plot,
            save_path=save_path,
            save_fname=save_fname,
            dpi=dpi,
            description="multi-task plot"
        )

        plt.show()

    def computeGroupPerf(
            self,
            data: pd.DataFrame,
            descriptor_groups: dict,
            metrics: list[str],
            exclude: list[str]=None
        ) -> pd.DataFrame:
        """
        Computes the average performance metrics for each descriptor group.

        This function takes a set of descriptors grouped by category (e.g., 
        from RDKit or Mordred) and calculates the mean value of the specified 
        performance metrics across all descriptors within each group. It is 
        typically used to summarise feature set performance before generating 
        grouped bar or radar plots.

        Parameters
        ----------
        data : pd.DataFrame
                            DataFrame containing descriptor names (as the index) 
                            and corresponding performance metric values.
        descriptor_groups : dict
                            Dictionary mapping descriptor group names to lists of 
                            descriptor columns. Can be generated using the 
                            `getGroups()` function for RDKit or Mordred descriptors.
        metrics : list[str]
                            One or more performance metrics to average across 
                            descriptor groups (e.g., ["Pearson_r", "R2"]).
        exclude : list[str] (optional)
                            List of descriptors to exclude from the averaging 
                            calculation.
                            Default = None.

        Returns
        -------
        pd.DataFrame
                            DataFrame containing the average values of the 
                            specified metrics for each descriptor group. Each 
                            row represents a descriptor group, and each column 
                            corresponds to an averaged metric.
        """
        
        # Exclude descriptors, if specified
        if exclude is None:
            exclude = []

        # Calculate group performances
        group_perf = {}
        for group, descs in descriptor_groups.items():
            valid = [d for d in descs if d in data.index and d not in exclude]
            if valid:
                group_perf[group] = data.loc[valid, metrics].mean()
        return pd.DataFrame.from_dict(group_perf, orient="index", columns=[f"avg_{metrics}"])

    def plotGroupRadar(
            self, 
            group_perf_df: pd.DataFrame,
            title: str="Radar Plot",
            figsize: tuple=(10,10),
            title_fontsize: int=16,
            label_fontsize: int=12,
            tick_fontsize: int=10,
            save_plot: bool=False,
            save_path: Union[str, Path]=None,
            save_fname: str="group_radar",
            dpi: int=400
    
        ):
        """
        Generates a radar (spider) plot visualising descriptor group performances 
        with dual scales for comparison (0–1 and 0.5–1).

        The radar plot highlights how each descriptor group contributes to overall 
        model performance, allowing easier comparison of strong and weak feature 
        sets across groups.

        Parameters
        ----------
        group_perf_df : pd.DataFrame
                            DataFrame containing descriptor group performance 
                            values, typically produced by the `computeGroupPerf()` 
                            function. The index should contain group names, and 
                            the first column should contain performance values.
        title : str (optional)
                            Title for the radar plot.
                            Default = "Radar Plot".
        figsize : tuple (optional)
                            Size of the figure as (width, height) in inches.
                            Default = (10, 10).
        title_fontsize : int (optional)
                            Font size for the plot title.
                            Default = 16.
        label_fontsize : int (optional)
                            Font size for the axis (descriptor) labels.
                            Default = 12.
        tick_fontsize : int (optional)
                            Font size for radial tick labels.
                            Default = 10.
        save_plot : bool (optional)
                            Whether to save the generated radar plot as an image.
                            Default = False.
        save_path : str, Path (optional)
                            Directory to save the plot to if `save_plot=True`.
                            Default = None.
        save_fname : str (optional)
                            Filename to save the plot under (without extension).
                            Default = "group_radar".
        dpi : int (optional)
                            Dots per inch (image resolution) for the saved plot.
                            Default = 400.

        Returns
        -------
        None
                            Displays the radar plot and optionally saves it to 
                            the specified directory.
        """

        

        labels = group_perf_df.index.tolist()
        values = group_perf_df.iloc[:,0].values
        values = np.append(values, values[0])
        angles = np.linspace(0, 2*np.pi, len(labels), endpoint=False)
        angles = np.append(angles, angles[0])

        # Set colour palette
        palette = sns.color_palette("tab10")
        blue, red = palette[0], palette[3]

        # Create the figure
        fig = plt.figure(figsize=figsize)

        # Axis 1 (0–1)
        ax1 = fig.add_subplot(111, polar=True)
        ax1.plot(
            angles, 
            values, 
            linewidth=2, 
            color=blue, 
            label="0–1 scale",
            alpha=0.5, 
            zorder=1
            )
        ax1.fill(angles, values, alpha=0.2, color=blue, zorder=0)

        # Configuring the y-ticks
        ax1.set_ylim(0,1)
        ticks_blue = np.arange(0,1.1,0.1)
        ax1.set_yticks(ticks_blue)
        ax1.set_yticklabels([f"{t:.1f}" if t>0 else "" for t in ticks_blue], 
                            color=blue, fontsize=tick_fontsize, fontweight="bold")
        
        # Configuring the x-ticks
        ax1.set_xticks(angles[:-1])
        ax1.set_xticklabels(labels, fontsize=label_fontsize, fontweight="bold")
        ax1.set_rlabel_position(90)

        # Axis 2 (0.5–1)
        ax2 = fig.add_subplot(111, polar=True, frame_on=False)
        ax2.plot(
            angles, 
            values, 
            linewidth=2, 
            color=red, 
            linestyle="--", 
            label="0.5–1 scale", 
            alpha=0.5, zorder=1
            )
            
        ax2.fill(angles, values, alpha=0.15, color=red, zorder=0)

        # Configuring the y-ticks
        ax2.set_ylim(0.5,1)
        ticks_red = np.arange(0.5,1.01,0.1)
        ax2.set_yticks(ticks_red)
        ax2.set_yticklabels([f"{t:.2f}" for t in ticks_red], 
                            color=red, fontsize=title_fontsize, fontweight="bold")
        
        # Configuring the x-ticks
        ax2.set_xticks([])
        ax2.set_xticklabels([])
        ax2.set_rlabel_position(270)

        # Merge legends
        handles1, labels1 = ax1.get_legend_handles_labels()
        handles2, labels2 = ax2.get_legend_handles_labels()
        plt.legend(
            handles1+handles2, 
            labels1+labels2, 
            loc="upper right", 
            bbox_to_anchor=(1.2,1.1), 
            fontsize=label_fontsize
            )

        plt.title(title, fontsize=title_fontsize, weight="bold", pad=40)

        self._savePlot(
            save_plot=save_plot,
            save_path=save_path,
            save_fname=save_fname,
            dpi=dpi,
            description="descriptor-grouped radar plot"
        )

    def plotGroupBar(
            self, 
            *group_dfs: pd.DataFrame,
            labels: list[str],
            x_label: str = "Descriptor Group",
            y_label: str = "Average Pearson r",
            title: str = "Group Comparison",
            figsize: tuple = (12,6),
            rotation: int = 45,
            title_fontsize: int=16,
            label_fontsize: int=12,
            tick_fontsize: int=10,
            save_plot: bool=False,
            save_path: Union[str, Path]=None,
            save_fname: str="grouped_barchart",
            dpi: int=400
        ):

        """
        Generates grouped bar charts comparing descriptor group performances 
        across multiple models or datasets.

        Each group of bars represents a descriptor group (e.g., atom counts, 
        surface properties), with one bar per model. This function is typically 
        used to visualise the output of the `computeGroupPerf` function.

        Parameters
        ----------
        *group_dfs : pd.DataFrame
                            DataFrames containing descriptor group performance 
                            values, typically produced by `computeGroupPerf()`. 
                            Each DataFrame corresponds to one model or dataset.
        labels : list[str]
                            Labels corresponding to each DataFrame (used for 
                            legend entries and color mapping). The number of 
                            labels must match the number of DataFrames.
        x_label : str (optional)
                            Label for the x-axis.
                            Default = "Descriptor Group".
        y_label : str (optional)
                            Label for the y-axis.
                            Default = "Average Pearson r".
        title : str (optional)
                            Title of the bar chart.
                            Default = "Group Comparison".
        figsize : tuple (optional)
                            Size of the figure as (width, height) in inches.
                            Default = (12, 6).
        rotation : int (optional)
                            Degree of rotation for the x-axis tick labels 
                            (e.g., 45 = 45 degrees).
                            Default = 45.
        title_fontsize : int (optional)
                            Font size for the plot title.
                            Default = 16.
        label_fontsize : int (optional)
                            Font size for axis labels.
                            Default = 12.
        tick_fontsize : int (optional)
                            Font size for tick labels.
                            Default = 10.
        save_plot : bool (optional)
                            Whether to save the generated plot as an image.
                            Default = False.
        save_path : str, Path (optional)
                            Directory to save the plot to if `save_plot=True`.
                            Default = None.
        save_fname : str (optional)
                            Filename to save the plot under (without extension).
                            Default = "grouped_barchart".
        dpi : int (optional)
                            Dots per inch (image resolution) for the saved plot.
                            Default = 400.

        Returns
        -------
        None
                            Displays the grouped bar chart and optionally saves 
                            it to the specified directory.
        """


        # Ensure labels are created or match number of dataframes provided
        if labels is None:
            labels = [f"Model{i+1}" for i in range(len(group_dfs))]
        if len(labels) != len(group_dfs):
            raise ValueError("Number of labels must match number of DataFrames")


        dfs_long = []
        for df, label in zip(group_dfs, labels):
            temp = df.copy()
            temp["dataset"] = label
            temp["group"] = temp.index
            dfs_long.append(temp)
        all_df = pd.concat(dfs_long)

        # Get colour from preset colour scheme
        palette = [self._getColour(l) for l in labels]

        # Initialise the figure
        plt.figure(figsize=figsize)
        sns.barplot(
            data=all_df,
            x="group",
            y=all_df.columns[0],
            hue="dataset",
            palette=palette
        )
        plt.xticks(rotation=rotation, ha="right", fontsize=tick_fontsize)
        plt.yticks(fontsize=tick_fontsize)
        plt.ylabel(y_label, fontsize=label_fontsize, weight="bold")
        plt.xlabel(x_label, fontsize=label_fontsize, weight="bold")
        plt.title(title, fontsize=title_fontsize, weight="bold")
        plt.legend(fontsize=label_fontsize)
        plt.tight_layout()

        self._savePlot(
            save_plot=save_plot,
            save_path=save_path,
            save_fname=save_fname,
            dpi=dpi,
            description="descriptor-grouped bar plot"
        )
        plt.show()

    def plotBar(
            self,
            data: pd.DataFrame,
            x_label: str,
            y_label: str,
            title: str=" ",
            figsize: tuple=(12,6),
            rotation: int=45,
            title_fontsize: int=16,
            label_fontsize: int=12,
            tick_fontsize: int=10,
            save_plot: bool=False,
            save_path: Union[str, Path]=None,
            save_fname: str="grouped_barchart",
            dpi: int=400
    ):
        
        """
        Generic function to generate a simple bar chart from a given DataFrame.

        The function plots a categorical variable on the x-axis and a numerical 
        variable on the y-axis, allowing for quick visual comparison of grouped 
        or individual values.

        Parameters
        ----------
        data : pd.DataFrame
                            DataFrame containing the data to be plotted.
        x_label : str
                            Column name representing the categories or bar labels 
                            to be plotted on the x-axis.
        y_label : str
                            Column name representing the numerical values to be 
                            plotted on the y-axis.
        title : str (optional)
                            Title for the bar chart.
                            Default = " ".
        figsize : tuple (optional)
                            Size of the figure as (width, height) in inches.
                            Default = (12, 6).
        rotation : int (optional)
                            Degree of rotation for the x-axis tick labels 
                            (e.g., 45 = 45 degrees).
                            Default = 45.
        title_fontsize : int (optional)
                            Font size for the plot title.
                            Default = 16.
        label_fontsize : int (optional)
                            Font size for axis labels.
                            Default = 12.
        tick_fontsize : int (optional)
                            Font size for tick labels.
                            Default = 10.
        save_plot : bool (optional)
                            Whether to save the generated plot as an image.
                            Default = False.
        save_path : str, Path (optional)
                            Directory to save the plot to if `save_plot=True`.
                            Default = None.
        save_fname : str (optional)
                            Filename to save the plot under (without extension).
                            Default = "grouped_barchart".
        dpi : int (optional)
                            Dots per inch (image resolution) for the saved plot.
                            Default = 400.

        Returns
        -------
        None
                            The function displays the generated bar chart and 
                            optionally saves it to the specified directory.
        """

        
        # Initialise the figure
        plt.figure(figsize=figsize)
        sns.barplot(
            data=data,
            x=x_label,
            y=data[y_label],
            palette="tab10"
        )
        plt.xticks(rotation=rotation, ha="right", fontsize=tick_fontsize)
        plt.yticks(fontsize=tick_fontsize)
        plt.ylabel(y_label, fontsize=label_fontsize, weight="bold")
        plt.xlabel(x_label, fontsize=label_fontsize, weight="bold")
        plt.title(title, fontsize=title_fontsize, weight="bold")
        plt.legend(fontsize=label_fontsize)
        plt.tight_layout()

        self._savePlot(
            save_plot=save_plot,
            save_path=save_path,
            save_fname=save_fname,
            dpi=dpi,
            description="bar chart"
        )

        plt.show()

    def plotBoxPlots(
            self,
            *data_dfs: pd.DataFrame,
            trained_labels: list[str],
            predicted_labels: list[str],
            title: str= " ",
            x_label: str="Models",
            y_label: str="Pearson_r",
            figsize=(16, 8),
            rotation: int=45,
            title_fontsize: int=16,
            label_fontsize: int=12,
            tick_fontsize: int=10,            
            save_plot: bool=False,
            save_path: Path=Path("./"),
            save_fname: str="box_plot",
            dpi: int=400
    ):
        
        """
        Function to generate grouped box plots for comparing model performance 
        between feature sets trained and predicted on different descriptor or 
        embedding spaces.

        Each box represents the distribution of metric values (e.g., Pearson r) 
        for a specific training–prediction pair. The box color indicates the 
        feature set the model was trained on, while the background color indicates 
        the feature set being predicted on.

        Parameters
        ----------
        *data_dfs: pd.DataFrame
                            DataFrames containing the numerical data to generate 
                            box plots from. Each DataFrame corresponds to a 
                            training–prediction feature pair.
        trained_labels: list[str]
                            Names of the feature sets that models were trained on.
        predicted_labels: list[str]
                            Names of the feature sets that models were used to 
                            make predictions on.
        title: str (optional)
                            Title of the overall plot.
        x_label: str (optional)
                            Label for the x-axis.
                            Default = "Models".
        y_label: str (optional)
                            Label for the y-axis (typically a performance metric 
                            such as Pearson r or R²).
                            Default = "Pearson_r".
        figsize: tuple (optional)
                            Figure size as (width, height) in inches.
                            Default = (16, 8).
        rotation: int (optional)
                            Degree of rotation for the x-axis tick labels 
                            (e.g., 45 = 45 degrees).
                            Default = 45.
        title_fontsize: int (optional)
                            Font size for the plot title.
                            Default = 16.
        label_fontsize: int (optional)
                            Font size for axis labels.
                            Default = 12.
        tick_fontsize: int (optional)
                            Font size for tick labels.
                            Default = 10.
        save_plot: bool (optional)
                            Flag to save the generated plot as an image.
                            Default = False.
        save_path: str, Path (optional)
                            Directory to save the plot to if `save_plot=True`.
                            Default = Path("./").
        save_fname: str (optional)
                            File name to save the plot under (without extension).
                            Default = "box_plot".
        dpi: int (optional)
                            Dots per inch (image resolution) for the saved plot.
                            Default = 400.

        Returns
        -------
        None
                            The function displays the plot and optionally saves it 
                            to the specified directory.
        """


        # Ensure number of dataframes and labels input match
        if not (len(data_dfs) == len(trained_labels) == len(predicted_labels)):
            raise ValueError("data_dfs, trained_labels, and predicted_labels must all have the same length")

        
        # Combine data
        combined = []
        for df, tr_label, pred_label in zip(data_dfs, trained_labels, predicted_labels):
            temp = df.copy()
            temp["trained_on"] = tr_label
            temp["predicted_on"] = pred_label
            dataset = f"{tr_label}-{pred_label}"
            temp["dataset"] = dataset
            
            # Adding suffix to ensure all feature_names are unique and identifiable
            temp.index = temp.index.astype(str) + f"_{dataset}"

            combined.append(temp)

        combined_df = pd.concat(combined, axis=0)

        # Get colour from preset colour scheme
        tr_palette = [self._getColour(l) for l in trained_labels]
        pred_palette = [self._getColour(l) for l in predicted_labels]

        # Initialise figure
        fig, ax = plt.subplots(figsize=figsize)

        # Draw background rectangles (predicted colors)
        y_min, y_max = combined_df[y_label].min(), combined_df[y_label].max()
        y_range = y_max - y_min
        datasets = combined_df["dataset"].unique()

        # Place rectangles on figure
        for i, (dataset, color) in enumerate(zip(datasets, pred_palette)):
            rect = patches.Rectangle(
                (i - 0.5, y_min - 0.05 * y_range),
                width=0.995,
                height=y_range * 1.1,
                color=color,
                alpha=0.25,
                zorder=0
            )
            ax.add_patch(rect)

        # Plot the boxplots (training colors)
        sns.boxplot(
            data=combined_df,
            x="dataset",
            y=y_label,
            palette=tr_palette[:len(datasets)],
            ax=ax,
            width=0.6,
            zorder=1,
            hue="dataset",
            legend=False
        )

        # Legend setup
        # Global legend (background vs box color)
        legend_patches = [
            patches.Patch(facecolor="grey", alpha=0.25, label="Predicted on (background)"),
            patches.Patch(facecolor="grey", label="Trained on (box color)")
        ]

        # Color key for training and predicted sources
        unique_sources = list(set(trained_labels + predicted_labels))
        color_key_patches = [
            patches.Patch(color=self._getColour(src), label=src) for src in unique_sources
        ]

        # Combine the legends
        first_legend = plt.legend(
            handles=legend_patches,
            loc="upper left",
            bbox_to_anchor=(1.02, 0.75),
            frameon=False,
            title="Colour meaning",
            fontsize=label_fontsize,
            title_fontsize=label_fontsize + 1
        )
        ax.add_artist(first_legend)

        plt.legend(
            handles=color_key_patches,
            loc="lower left",
            bbox_to_anchor=(1.02, 0.25),
            frameon=False,
            title="Colour key",
            fontsize=label_fontsize,
            title_fontsize= + 1
        )

        # Labels & formatting
        ax.set_title(title, fontsize=title_fontsize + 2, weight="bold", pad=15)
        ax.set_xlabel(x_label, fontsize=label_fontsize)
        ax.set_ylabel(y_label, fontsize=label_fontsize)
        plt.xticks(rotation=rotation, ha="right", fontsize=tick_fontsize)
        plt.yticks(fontsize=tick_fontsize)
        plt.tight_layout(rect=[0, 0, 0.7, 1])
        plt.show()

        self._savePlot(
            save_plot=save_plot,
            save_path=save_path,
            save_fname=save_fname,
            dpi=dpi,
            description="descriptor-grouped bar plot"
        )

    def plotGroupHeatmaps(
            self,
            data: pd.DataFrame,
            descriptor_groups: dict,
            metric: str = "Pearson_r",
            title_prefix: str = "Descriptor Performance",
            cmap: str = "viridis",
            annot: bool = True,
            vmin: float = 0.0,
            vmax: float = 1.0,
            ascending: bool=False,
            title_fontsize: int=16,
            label_fontsize: int=12,
            tick_fontsize: int=10,            
            save_plot: bool=False,
            save_path: Path=Path("./"),
            save_fname: str="box_plot",
            dpi: int=400
        ):
        """
        Generates one heatmap per descriptor group, visualising the performance of 
        descriptors within each group for a specified metric (e.g., Pearson r).

        Each group is plotted separately as an individual heatmap, allowing for 
        comparison of descriptor performance across different descriptor families.

        Parameters
        ----------
        data : pd.DataFrame
                        DataFrame containing descriptor names as the index and 
                        performance metrics (e.g., Pearson r) as columns.
        descriptor_groups : dict
                        Dictionary mapping group names (e.g., "Atom Counts") to 
                        lists of descriptor names that belong to that group.
        metric : str, (optional)
                        Column name in `data` to visualise in the heatmap.
                        Default = "Pearson_r".
        title_prefix : str, (optional)
                        Prefix for the heatmap title. Each figure’s title will 
                        be formatted as: "{title_prefix}: {group}".
                        Default = "Descriptor Performance".
        cmap : str, (optional)
                        Name of the colour map to use for the heatmap.
                        Default = "viridis".
        annot : bool, (optional)
                        Whether to annotate each cell with its metric value.
                        Default = True.
        vmin : float, (optional)
                        Minimum value for the colour scale. 
                        Default = 0.0.
        vmax : float, (optional)
                        Maximum value for the colour scale. 
                        Default = 1.0.
        ascending : bool, (optional)
                        Determines sort order of descriptors by metric value.
                        True = low to high, False = high to low.
                        Default = False.
        title_fontsize : int, (optional)
                        Font size for the heatmap title.
                        Default = 16.
        label_fontsize : int, (optional)
                        Font size for axis labels.
                        Default = 12.
        tick_fontsize : int, (optional)
                        Font size for tick labels.
                        Default = 10.
        save_plot : bool, (optional)
                        Flag to save each generated heatmap as an image file.
                        Default = False.
        save_path : Path, (optional)
                        Directory path to save the heatmaps if `save_plot=True`.
                        Default = Path("./").
        save_fname : str, (optional)
                        Base filename to save the plots under. The group name 
                        will be appended automatically (e.g., "box_plot_RDKit.png").
                        Default = "box_plot".
        dpi : int, (optional)
                        Image resolution (dots per inch) for saved heatmaps.
                        Default = 400.

        Returns
        -------
        None
                        The function displays each heatmap and optionally saves it 
                        to the specified directory.
        """


        # Iterate through the groups and descriptors
        for group, descs in descriptor_groups.items():
            valid = [d for d in descs if d in data.index]
            if not valid:
                continue
            
            # Sort metrics
            df_group = data.loc[valid, [metric]].sort_values(metric, ascending=ascending)

        # Initialise figure
            plt.figure(figsize=(6, max(4, len(valid) * 0.25)))
            sns.heatmap(df_group,
                        cmap=cmap,
                        annot=annot,
                        fmt=".2f",
                        cbar_kws={"label": metric},
                        vmin=vmin,
                        vmax=vmax,
                        annot_kws={"fontsize": tick_fontsize})
            plt.title(f"{title_prefix}: {group}", fontsize=title_fontsize, weight="bold", pad=20)
            plt.ylabel("Descriptor", fontsize=label_fontsize, weight="bold")
            plt.xlabel("")
            plt.yticks(fontsize=tick_fontsize)
            plt.tight_layout()


            self._savePlot(
                save_plot=save_plot,
                save_path=save_path,
                save_fname=f"{save_fname}_{group}",
                dpi=dpi,
                description=f"{group} heatmap"
            )
            
            plt.show()

    def plotModelPerformanceBars(
            self,
            base_path: Path,
            model_jsons: dict[str, Path],
            model_labels: list[str],
            metrics: list[str] = ["r2", "Pearson_r", "RMSE", "Bias"],
            figsize: tuple = (6, 4),
            title_fontsize: int = 16,
            label_fontsize: int = 12,
            tick_fontsize: int = 10,
            save_plot: bool = False,
            save_path: Path = Path("./"),
            save_fname: str = "model_performance",
            dpi: int = 400,
    ):
        """
        Generates individual bar plots comparing model performance metrics 
        (e.g., R², Pearson r, RMSE, Bias) across multiple trained models.

        Each metric is plotted in its own figure, allowing for clear visual 
        comparison of model performance. The function supports automatic 
        color mapping, customizable aesthetics, and optional saving of plots.

        Parameters
        ----------
        base_path : Path
                        Base directory containing all model result folders.
                        Used as a reference path for loading model performance JSONs.
        model_jsons : dict[str, Path]
                        Dictionary mapping model names to their respective JSON 
                        performance files (relative to `base_path` or as absolute paths).
        model_labels : list[str]
                        Labels or display names for the models. These determine 
                        color mapping and order in the plots.
        metrics : list[str], (optional)
                        List of performance metrics to visualize. Each metric 
                        will be plotted as a separate bar chart.
                        Default = ["r2", "Pearson_r", "RMSE", "Bias"].
        figsize : tuple, (optional)
                        Figure size (width, height) for each individual metric plot.
                        Default = (6, 4).
        title_fontsize : int, (optional)
                        Font size for the plot titles.
                        Default = 16.
        label_fontsize : int, (optional)
                        Font size for axis labels (x and y labels).
                        Default = 12.
        tick_fontsize : int, (optional)
                        Font size for tick labels on both axes.
                        Default = 10.
        save_plot : bool, (optional)
                        Whether to save the generated plots to disk.
                        Default = False.
        save_path : Path, (optional)
                        Directory path where plots will be saved if `save_plot=True`.
                        Default = Path("./").
        save_fname : str, (optional)
                        Base filename for saved plots. The metric name will be 
                        appended automatically (e.g., "model_performance_r2.png").
                        Default = "model_performance".
        dpi : int, (optional)
                        Dots per inch (image resolution) for saved plots.
                        Default = 400.

        Returns
        -------
        None
                        The function displays each plot and optionally saves it 
                        to the specified directory.
        """

        # --- Load JSONs into DataFrame ---
        records = []
        for model, file in model_jsons.items():
            file_path = base_path / file if not file.is_absolute() else file
            with open(file_path, "r") as f:
                data = json.load(f)
                data["Model"] = model
                records.append(data)

        perf_df = pd.DataFrame(records).set_index("Model")

        # --- Setup colors ---
        colours = [self._getColour(l) for l in model_labels]

        # --- Plot metrics ---
        for metric in metrics:
            plt.figure(figsize=figsize)
            bars = plt.bar(
                perf_df.index,
                perf_df[metric],
                color=colours,
                edgecolor="black",
            )
            plt.title(f"{metric} Comparison", fontsize=title_fontsize, weight="bold")
            plt.ylabel(metric, fontsize=label_fontsize)
            plt.xlabel("Model", fontsize=label_fontsize)
            plt.xticks(rotation=45, ha="right", fontsize=tick_fontsize)
            plt.yticks(fontsize=tick_fontsize)
            plt.tight_layout()

            self._savePlot(
                save_plot=save_plot,
                save_path=save_path,
                save_fname=f"{save_fname}_{metric}",
                dpi=dpi,
                description=f"model performance bar charts"
            )
        
            plt.show()

    def plotPCA (
        self,
        data_dict: dict[str, pd.DataFrame, Path],
        n_components: int = 5,
        loadings_filename: str = "pca_loadings",
        pca_df_filename: str = "pca_components",
        contamination: float = 0.00001,
        plot_area: bool = False,
        plot_scatter: bool = True,
        random_seed: int = None,
        plot_loadings: bool = False,
        plot_title: str = " ",
        remove_outliers: bool = True,
        axis_fontsize: int = 18,
        label_fontsize: int = 16,
        legend_fontsize: int = 14,
        save_plot: bool = False,
        save_path: Path=Path("./"),
        save_fname: str="PCA_plot",
        dpi: int=400,
        save_extra_data: bool = False,
        wildcard: str="*"
    ):

        """
        Function to perform and visualise Principal Component Analysis (PCA) 
        for any number of datasets provided as a dictionary. Each dataset is 
        automatically filtered to retain only common numeric columns across 
        all inputs, and the resulting PCA is plotted with pairwise scatter/KDE 
        subplots, optional convex hull overlays, and bar charts for feature loadings.

        Parameters
        ----------
        data_dict : dict[str, pd.DataFrame, Path]
                        Dictionary mapping dataset names to either pandas DataFrames 
                        or file paths containing the data to include in the PCA.
        n_components : int, (optional)
                        Number of principal components to compute and visualise.
        loadings_filename : str, (optional)
                        Base filename for saving PCA loadings data.
        pca_df_filename : str, (optional)
                        Base filename for saving the transformed PCA component data.
        contamination : float, (optional)
                        Fraction of data points considered outliers for removal 
                        using the Local Outlier Factor method.
        plot_area : bool, (optional)
                        Flag to enable convex hull overlays showing the spread of 
                        each dataset in PCA space.
        plot_scatter : bool, (optional)
                        Flag to enable scatter plot points for PCA components.
        random_seed : int, (optional)
                        Random seed to ensure reproducibility of PCA results. 
                        If None, a random seed will be generated and printed.
        plot_loadings : bool, (optional)
                        Flag to generate and save an additional bar chart showing 
                        the feature loadings for each principal component.
        plot_title : str, (optional)
                        Title to display at the top of the PCA plot.
        remove_outliers : bool, (optional)
                        Whether to remove outliers before plotting, using the 
                        Local Outlier Factor method.
        axis_fontsize : int, (optional)
                        Font size for axis titles (e.g., PC1, PC2 labels).
        label_fontsize : int, (optional)
                        Font size for individual subplot axis labels.
        legend_fontsize : int, (optional)
                        Font size for the legend text in the PCA plot.
        save_plot : bool, (optional)
                        Flag to save the generated PCA plots as image files.
        save_path : Path, (optional)
                        Directory path to save the generated plots and data.
        save_fname : str, (optional)
                        Base filename to save the PCA plot image under.
        dpi : int, (optional)
                        Dots per inch (image resolution) for the saved plots.
        save_extra_data : bool, (optional)
                        Flag to save additional PCA-related data such as loadings 
                        and transformed component tables.
        wildcard : str, (optional)
                        The symbol used to denote multiple file paths in the 
                        input data_dict, typically '*' or '?'.

        Returns
        -------
        fig : matplotlib.figure.Figure
                        The generated PCA plot figure object.
        pca_df : pd.DataFrame
                        DataFrame containing the PCA-transformed component values 
                        and corresponding dataset source labels.
        loadings_df : pd.DataFrame
                        DataFrame of PCA feature loadings for each principal component.
        abs_loadings_df : pd.DataFrame
                        DataFrame of absolute feature loadings, useful for identifying 
                        the most influential features across components.
        """
        if random_seed is None:
            random_seed = rand.randint(0, 2**31)
            print(f"PCA random seed: {random_seed}")
        np.random.seed(random_seed)

        full_loaded_data = {}
        numeric_cols = {}

        # Load and label all datasets
        for key, df in data_dict.items():
            loaded_df = self._loadData(df=df, index_col="ID", wildcard=wildcard)
            loaded_df["Source"] = key
            full_loaded_data[key] = loaded_df

            # Identify where columns only contain numerical values
            numeric_cols[key] = [
                col for col in loaded_df.columns
                if pd.to_numeric(loaded_df[col], errors="coerce").notna().all()
                ]

        data_dict = full_loaded_data

        # Set common columns and discard any non-numerical ones
        common_cols = set.intersection(*[set(cols) for cols in numeric_cols.values()])
        common_cols = list(common_cols)

        if not common_cols:
            raise ValueError("No common numeric columns found across datasets.")
        
        # Combining data frames
        combined_df = pd.concat(
            [df[common_cols + ["Source"]] for df in data_dict.values()],
            axis=0
        ).dropna()

        # Scale & Create PCA
        scaler = StandardScaler()
        scaled = pd.DataFrame(
            scaler.fit_transform(combined_df[common_cols]),
            columns=common_cols,
            index=combined_df.index,
        )
        scaled["Source"] = combined_df["Source"]

        pca = PCA(n_components=n_components)
        principal_components = pca.fit_transform(scaled[common_cols])
        explained_var = pca.explained_variance_ratio_ * 100

        # --- Loadings
        loadings = pca.components_.T * np.sqrt(pca.explained_variance_)
        loadings_df = pd.DataFrame(loadings, columns=[f"PC{i+1}" for i in range(n_components)], index=common_cols)
        abs_loadings_df = loadings_df.abs().rename_axis("Features")

        if save_extra_data:
            loadings_df.to_csv(save_path / f"{loadings_filename}.csv", index_label="Features")
            abs_loadings_df.to_csv(save_path / f"{loadings_filename}_abs.csv", index_label="Features")

        # --- PCA dataframe
        pca_df = pd.DataFrame(principal_components, columns=[f"PC{i+1}" for i in range(n_components)], index=combined_df.index)
        pca_df["Source"] = combined_df["Source"]

        if save_extra_data:
            pca_df.to_csv(save_path / f"{pca_df_filename}.csv.gz", index_label="ID", compression="gzip")

        # --- Outlier removal
        if remove_outliers:
            lof = LocalOutlierFactor(n_neighbors=20, contamination=contamination)
            mask = lof.fit_predict(pca_df[[f"PC{i+1}" for i in range(n_components)]])
            pca_df = pca_df[mask == 1]

        # --- Colors
        palette = sns.color_palette('dark')
        source_colors = {src: palette[i % len(palette)] for i, src in enumerate(data_dict.keys())}

        # --- Subplots
        fig, axs = plt.subplots(n_components, n_components, figsize=(10, 10))

        for i in range(n_components):
            for j in range(n_components):
                if i == j:
                    # KDE diagonal
                    sns.kdeplot(
                        x=f"PC{i+1}",
                        hue="Source",
                        data=pca_df,
                        common_norm=False,
                        fill=True,
                        ax=axs[i, i],
                        palette=source_colors,
                        legend=False,
                    )
                    axs[i, i].set_ylabel("Density", fontsize=label_fontsize)
                else:
                    if plot_scatter:
                        sns.scatterplot(
                            x=f"PC{j+1}",
                            y=f"PC{i+1}",
                            hue="Source",
                            data=pca_df,
                            ax=axs[i, j],
                            palette=source_colors,
                            legend=False,
                            alpha=0.2,
                            s=10
                        )
                    if plot_area:
                        for src in pca_df["Source"].unique():
                            pts = pca_df[pca_df["Source"] == src][[f"PC{j+1}", f"PC{i+1}"]].values
                            if len(pts) > 3:
                                hull = ConvexHull(pts)
                                hull_pts = np.append(hull.vertices, hull.vertices[0])
                                axs[i, j].fill(
                                    pts[hull_pts, 0], pts[hull_pts, 1],
                                    alpha=0.2, color=source_colors[src], edgecolor=source_colors[src]
                                )

                # Labels
                if i == n_components - 1:
                    axs[i, j].set_xlabel(f"PC{j+1} ({explained_var[j]:.1f}% var)", fontsize=axis_fontsize)
                if j == 0:
                    axs[i, j].set_ylabel(f"PC{i+1} ({explained_var[i]:.1f}% var)", fontsize=axis_fontsize)

        # Legend
        handles = [
            plt.Line2D([], [], color=source_colors[src], marker="o", linestyle="None", markersize=8, label=src)
            for src in pca_df["Source"].unique()
        ]
        fig.legend(handles=handles, loc="upper center", ncol=len(data_dict.keys()), fontsize=legend_fontsize, frameon=False)
        fig.suptitle(plot_title, fontsize=axis_fontsize + 4, y=1.02)
        plt.tight_layout()

        self._savePlot(
            save_plot=save_plot,
            save_path=save_path,
            save_fname=save_fname,
            dpi=dpi,
            description="PCA plot",
            fig=fig
        )

        # Optional loadings plot (messy)
        if plot_loadings:
            loadings_df["Max"] = loadings_df.abs().max(axis=1)
            sig_loadings = loadings_df[loadings_df["Max"] > 0.3].drop(columns="Max")
            fig2, axes = plt.subplots(n_components, 1, figsize=(20, 18), sharex=True)
            for n in range(1, n_components + 1):
                sns.barplot(x=sig_loadings.index, y=sig_loadings[f"PC{n}"], ax=axes[n - 1])
                axes[n - 1].set_ylabel(f"PC{n} Loadings", fontsize=label_fontsize)
            plt.xticks(rotation=90)
            fig2.tight_layout()

            self._savePlot(
                save_plot=save_plot,
                save_path=save_path,
                save_fname=f"{save_fname}_loadings",
                dpi=dpi,
                description="PCA plot loadings (bar chart)",
                fig=fig2
            )

        return fig, pca_df, loadings_df, abs_loadings_df
    
    def plotPredictions(
            self,
    ):
        return